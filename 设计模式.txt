SRP,单一职责原则：编写程序的标准 要求类和接口职责单一（业务逻辑）
衡量标准：类或者接口的职责，变化原因
适用于接口、类、方法


SLP,里氏替换原则
父类出现的地方可以替换成子类，反之不成立
在类中调用其他类时务必要使用父类或接口，否则，违背了LSP
如果子类不能完整的实现父类的方法或者父类的方法在子类中已经发生了畸变，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承
downcast 向下转型 不安全
子类的前置条件必须与父类的覆写（@override）的方法的前置条件相同或者更宽松,覆写或实现父类的方法时输出结果可以被缩小


DIP，依赖倒置原则 细节（实现类）依赖抽象（接口和抽象类），高模块不能依赖低模块，都应该依赖抽象（OOD，面向接口编程）
被依赖者的变更不该让依赖者来承担
表面类型：IDriver 实际类型：Driver
依赖倒置原则规则：每个类都尽量有接口或者抽象类，或者两者兼有
变量的表面尽量是接口或者抽象类（工具类除外，实现类使用clone方法）
任何类都不应该从具体类派生
尽量不要覆写基类的方法
结合里氏替换原则使用
接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化


接口隔离原则：（要求接口的方法尽量少，尽量使用多个专门的接口，提供给每个模块的都应该是单一的接口，提供给几个模块的就应该是几个接口，而不是一个庞大的臃肿的接口）
实例接口（Object interface）Person zs=new Person();Person类时zs的接口，实例要遵从的标准就是Person类
类接口（class interface）由interface关键字定义
接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的可维护性和灵活性
接口要尽量小（拆分时先要满足单一职责原则）
接口要高内聚（接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统开发越有利，变更风险，成本会降低）
定制服务（单独为一个个体提供优良的服务）只提供访问者需要的方法（图书管理系统公网简单查询，管理员简单查询、复杂查询）
接口设计是有限的
一个接口只服务于一个子模块或者业务逻辑、通过业务逻辑压缩接口中的public方法、修改污染接口风险大时，采用适配器模式进行转换处理，深入了解业务逻辑设计接口

LoD(LKP)迪米特法则
朋友类：出现在成员变量、方法的输入输出参数中的类，出现在方法体内部的类不属于朋友类，
一个类只与朋友类交流，getA().getB().getC().getD(),尽量不用，每个点后面的返回类型相同时可以
类与类之间的联系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象（JDK API提供的类除外）
尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private,package-private,protected,final等访问权限
方法是自己的就是自己的（不增加类间关系，对本类不产生负面影响）
谨慎使用serializable






































































































































































































































































































































































































































































































































































